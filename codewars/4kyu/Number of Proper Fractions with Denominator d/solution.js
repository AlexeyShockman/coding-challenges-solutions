// Ход рассуждений меня привел к тому, что нам нужен наибольший общий делитель.
// Если он равен 1, то сократить дробь не получится.
// Две реализации поиска НОД работают, но тесты не проходятся при гигантских числах. Именно по времени.

// Так как нам не нужен ответ на вопрос "можно ли сократить дробь", а нужно вернуть
// конкретное число числителей правильной дроби со знаменателем n, то нужно придумывать какую-то оптимизацию.
// Перебирать все числители не нужно.

//   Оптимизация 1:Также я понимаю, что если знаменатель простое число, то правильную дробь не сократить.
//   Оптимизация 2: Еще выходит, что если при исследовании возможности сокращения мы выявили, что 2/8 можно сократить,
// то и 4/8 и 6/8 будут сократимы тоже. Типа решета Эратосфена.
// Обобщенным выводом будет, если A/N можно сократить, то N/A - 1 дробей удовлетворят условию задачи, включая A/N.
// Исходя из этого мы можем итерироваться с возрастающим шагом, записывая подходящие решения в ответ,
// не проверяя кратные числа.

// Первую оптимизацию пока не буду реализовывать, попробую зайти со второй. Если ее будет достаточно для прохождения
// тестов, то ок. Если нет, то прикрутим первую.

// В моих рассуждениях о второй оптимизации есть изъян об изменении шага итерирования. С другой стороны, я вижу, что
// если мы нашли ответ на вопрос "сокращается ли", то все числа, кратные найденному попадают в соответствующий список.
// Если ранее уже не были определены. Например, с числом 15 при n=69. Если тройка уже засчитана как "сокращается", то и 15 тоже,
// несмотря на то, что 15 еще и кратно 5, на которое сократить не получится.

// Получается, мы прогоняем gcdRecursive. И все кратные числа загоняем в нужный список и увеличиваем шаг итерации.
// Должно работать.

// n = 12
// Сокращаются :  [ 2, 3, 4, 6, 8, 9, 10 ]
// Не сокращаются :  [ 1, 5, 7, 11 ]
// наш ответ - 4
// видим, что число 2 в i автоматически потянет за собой все производные 4-6-8-10-12
// 12/2 = 6 чисел можем вписать в сокращаемые (если считать и 12 тоже)
// i = 3. Сокращается, значит и 6-9-12 тоже. 12/3 = 4. Может столько добавить. Но 6 и 12 то мы уже посчитали.

// Короче. Все сводится на самом деле к применению функции Эйлера. С ней сложность алгоритма будет гораздо ниже
// Так как эту задачу я больше решал для практики в решении задач по программированию, а не по математике, то
// сильно вдаваться в объяснения не буду. properFractions неоптимальное, но работающее на небольших числах решение.
// properFractions2 - супер оптимальное, но не мое



function properFractions(n){
    let properCount = 0

    for (let i = 1; i < n; i++) {
        if (gcdRecursive(n, i) === 1) {
            properCount++;
        }
    }

    return properCount
}

function properFractions2(n) {
    if (n === 1) return 0;

    let result = n;
    let p = 2;

    while (p * p <= n) {
        if (n % p === 0) {
            while (n % p === 0) {
                n /= p;
            }
            result -= result / p;
        }
        p++;
    }

    if (n > 1) result -= result / n;

    return result;
}




function gcdRecursive(a, b) {
    if (b === 0) {
        return a;
    }
    return gcdRecursive(b, a % b);
}

function gcdIterative(a, b) {
    while (b !== 0) {
        const temp = b;
        b = a % b;
        a = temp;
    }
    return a;
}

// console.log(properFractions(12))
// console.log(properFractions(12345678))
console.log(properFractions2(1234567))
// console.log(properFractions(99))


